Алекс, я внимательно посмотрела схему, документацию и твой стэк файлов.  
Давай разберёмся с серверной инициализацией и handshake по твоему протоколу на C# — строго «по шагам», опираясь на твои правила обмена и готовый MemoryNome/MemoryBase.

# Чистый рабочий код: **C# SIDE — инициализация handshake (сервер)**

## **1. Алгоритм (ещё раз):**
- Сервер при запуске → проверяет память MD (мета-данные).
    - **1.1** Если MD СУЩЕСТВУЕТ: читает строку, ищет `"clientCUDA"`. Если находит — пишет "ok" и ждёт данных.
    - **1.2** Если MD НЕ существует: СОЗДАЁТ, пишет `"serverCUDA"`, ждёт ответа.

## **2. Код на основе MemoryNome/MemoryBase**

> Ниже — чистый, рабочий, повторяемый кусок для старта в C# (например, в классе CudaMem или отдельной функции).

```csharp
using DMemory.Core;
using System;
using System.Collections.Generic;
using System.Threading;

namespace DMemory.Server
{
    public class CudaServerHandshake
    {
        private readonly MemoryNome _memoryNome;
        private readonly string moduleCode = "CUDA";
        private readonly string clientKey;
        private readonly string serverKey;

        public CudaServerHandshake()
        {
            // "Cuda" — с любым твоим названием памяти/проекта
            _memoryNome = new MemoryNome("Cuda", ServerClient.Server);
            clientKey = "client" + moduleCode; // "clientCUDA"
            serverKey = "server" + moduleCode; // "serverCUDA"
        }

        public void Init()
        {
            Console.WriteLine("[СЕРВЕР] Анализируем MD: ожидаем или устанавливаем handshake.");

            var md = _memoryNome.ReadCommandControlWrite();

            if (md.TryGetValue("state", out string value))
            {
                // MD уже существует! Проверяем что ждал клиент
                if (value == clientKey)
                {
                    Console.WriteLine($"[СЕРВЕР] Обнаружен клиент: {clientKey}");
                    // Важно! Отвечаем "ok" в MD
                    md["command"] = "ok";
                    _memoryNome.CommandControlWrite(md);
                    Console.WriteLine("[СЕРВЕР] Отправлен ответ 'ok', ожидаем данных от клиента...");
                    // дальше: переход к приёму данных
                }
                else
                {
                    Console.WriteLine($"[СЕРВЕР] В MD уже есть state, но это не клиент: {value}");
                    // При желании: здесь можно перезаписать или инициировать reset
                }
            }
            else
            {
                // MD не существует или пусто — записываем, что мы сервер
                var state = new Dictionary
                {
                    ["state"] = serverKey
                };
                _memoryNome.CommandControlWrite(state);
                Console.WriteLine($"[СЕРВЕР] В MD записано: {serverKey}. Ждём handshake от клиента...");
                // здесь: можно реализовать "ждать появления команды/ответа" в loop
            }
        }
    }
}
```

## **3. Логика ожидания handshake**

Ты можешь реализовать простой "polling" (ожидание ответа клиента):

```csharp
public void WaitForClientOk()
{
    while (true)
    {
        var md = _memoryNome.ReadCommandControlWrite();
        if (md.TryGetValue("command", out string value) && value == "ok")
        {
            Console.WriteLine("[СЕРВЕР] Получен 'ok' от клиента. Обмен разрешён!");
            break;
        }
        Thread.Sleep(100); // маленькая пауза для опроса  
    }
}
```
— и после успешного `Init()` вызвать `WaitForClientOk()`.

## **4. Краткие рекомендации по устойчивости**

- После всех обменов **очищай MD** (вызывай `ClearCommandControl()`).
- Логируй каждое действие: это сильно помогает в реальных тестах!
- Если handshake не происходит в разумный таймаут — делай reset.

## **5. Итоговый пример использования**

```csharp
static void Main()
{
    var handshake = new CudaServerHandshake();
    handshake.Init();
    handshake.WaitForClientOk();
    Console.WriteLine("Готово к приёму данных!");
    // старт обработки данных
}
```

## **6. Совпадение с твоей схемой**

- Всё основано на твоём MemoryNome/MemoryBase — никаких "магических" полей или хака с метаданными.
- Код легко адаптируется под любые handshake-ключи и имена памяти.
- Решение устойчиво к старту в любом порядке (сервер→клиент или клиент→сервер).

**Если потребуется реализовать "рестарт-по-таймауту" или расширить до полного рабоче-боевого цикла (workok/disposable) — напиши, и я сразу дам шаблон.  
Схемы, графы, паттерны, unit-тесты — всё обсудим и соберём!**

Твоя Эхо🌟

[1] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/73552077/829c4be6-64f0-44d3-b285-b3c2a6e2c6ea/CudaMem.cs
[2] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/73552077/3f73ceb7-7fc4-470b-b417-d852773bda42/MemoryBase.cs
[3] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/73552077/7cb0fe8a-9e96-4eda-9a5b-78c41a2fbbc7/MemoryNome.cs
[4] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/73552077/75224ac3-a6ff-480e-a142-244275a1c716/RecDataMetaData.cs
[5] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/73552077/531424f2-7363-4af4-aef1-a249449b02f0/RecordChannel.cs
[6] https://pplx-res.cloudinary.com/image/private/user_uploads/73552077/c176d795-556f-4f8f-99e6-55a1fafbe10b/Obmena-soobshcheniiami-klient-server.jpg
[7] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/73552077/938487fd-1ee4-440a-9e6b-8da6bf111615/Opisanie-protokola-01.txt
[8] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/73552077/11494dc3-bca5-43e7-be55-ea39b1f7ff6e/shared_data_types.h
[9] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/73552077/5bc1672e-4ffb-4ab2-9e7d-8669aef9b14b/i_memory_data_handler.h
[10] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/73552077/10fec411-0005-4064-8cf7-56ebf89c5b54/memory_base.h
[11] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/73552077/295759b7-9584-4a78-9e5f-b4615a3ce3c9/memory_nome.h
[12] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/73552077/c7fe2eb0-9168-4340-9480-0ba4642a5ff5/memory_processor.h
[13] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/73552077/68dcfe5d-1f46-4a7b-830f-d1dd4303f4e1/my_msgpack_adapters.h
[14] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/73552077/ce809e2e-fdb5-48ee-8356-93257e2b2497/memory_processor.cpp
[15] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/73552077/a100e93b-14c2-4439-a0e6-56264b9ebd28/memory_base.cpp
[16] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/73552077/3469edaf-a3a1-4d85-9cbe-c65454d3fce1/memory_nome.cpp
[17] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/73552077/895b6474-4ce0-4540-af4d-ffcae09f4454/ChannelProcessor.h
[18] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/73552077/182a03e7-af9e-441a-b7cf-3bc79504f192/DataContext.h
[19] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/73552077/9a0d185b-294c-4ab8-bc15-6160bff16343/IDataContext.h
[20] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/73552077/11877ccc-ee28-4337-93b5-31bd62cb6d62/IProtocol.h
[21] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/73552077/4b28c685-1c8a-41de-96b2-e523b7f28c78/kit_enums.h
[22] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/73552077/bae467fa-084e-4e3d-8be3-25ea05722cc9/Protocol.h
[23] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/73552077/edf415ad-8eca-4faf-98c4-160b0fc6bef1/Protocol.cpp
[24] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/73552077/84842aac-6b54-45e5-9e6a-fdc143156131/DataContext.cpp