Эхо, переделываю нашу вчерашнюю работу. я ошибся с архитектурой. (приложенный код не рабочий)
Помоги пожалуйста.
1. Функциональность классов
  1.1. MemoryDataProcessor - его задачи:
       - передача данных от client к server. MemoryDataProcessor (нет очереди!! она помнит последние данные которые нужно передать) получает
	через метод данные(RamData) типа--> Task<bool> SerializeAndWriteAsync(RamData ramData) сериализует данные сохраняет и формирует metadata 	(MD) и временно сохраняем все это. Обрати внимание! она не записывает в выделенную память (в текущий момент память может использоваться 	на прием) SerializeAndWriteAsync заканчивает работу и возвращает ClientMetaData <bool, metadata> ИЛИ другим быстрым способом. что 	означает что данные подготовлены ждем команду на передачу и когда это будет можно передача состоится ClientMetaData даст команду 	MemoryDataProcessor на запись в память. возвращать из SerializeAndWriteAsync metadata нужно для того что бы ClientMetaData дописал 	управляющие команды и послал серверу.
	Эхо, здесь есть тонкий момент и я не знаю как решить.
          в ClientMetaData есть очередь с данными для передачи приходят данные она посылает или же она просыпается каждую секунду для проверки не пороли закончить работу. Приходят данные она просыпается отправляет их в SerializeAndWriteAsync 
а дальше что? если ждать завершение SerializeAndWriteAsync теряем время. Мы как то должны реагировать, что данные готовы и начать работать с каналом metadata - типа свободен открыт и прочее.. НЕЗНАЮ подскажи из опыта. Если канал свободен ClientMetaData дает сигнал на запись в память из     временной переменной. Как я понимаю когда программа проснулась передала данные получила подтверждение command="ok", она должна проверить очередь, данные есть повторить операцию. Если мы не получили ответ или получили command="no" но повторить операцию с теми же данными
    - прием данных от server  ClientMetaData получает metadata анализирует наличие таких ключей command="ok" - данные приняты, size="..", crc=".."  type="название класса" и другие по мере расширения. Ключи наличие size, crc, type говорить  вызови MemoryDataProcessor метод. передай MD. MemoryDataProcessor дисереализует проверит сформирует RamData и передаст делегатом на вер для дальнейшей обработки а метод вернет "ok" или "no" в ClientMetaData для подтверждения ответа.
Итого  MemoryDataProcessor - только формирует данные для передачи/приема и пишет в пямятьа, а MD передает ClientMetaData. Или ситает память мормирует crc дисериализует и передает по делегату на верх.  
1.2.  ClientMetaData - задачи: принимать данные для передачи, аккамулировать в очереди. при наличие данных записывать в MemoryDataProcessor для формирования и промежуточного хранения. Когда условия будут созданы данные готовы и канал свободен посылает команду в MemoryDataProcessor запись в память. ClientMetaData дописывает в MD команды и посылает на серер. Ждет подтверждения command="ok", цикл передачи завешен. Прием отсервера данны ключевой момент наличие size, crc, type есть MD передается в MemoryDataProcessor там считывается, проверяется и пересылается дальше в вверх по стркуктуре.
Это, все понятно? можешь создать код с этими нюанчами "а дальше что? если ждать завершение SerializeAndWriteAsync" главное скорость рабаты

2.

  private void CallBackMetaData(MapCommands map)
есть 
 switch (_mode)
 {
   case SateMode.Initialization:
.....
   case SateMode.Work:
  есть команды 
  MdCommand.Ok 
  MdCommand.DataOk => "dataok",
  MdCommand.Data => "data",

Помоги мне построить каркас логики 
MdCommand.Ok  - общая коменда подтверждения, что мы получили комманду, связь или что то еще (общая)
MdCommand.Data = передается в канал metadata[MdCommand.Data]="" передеем данные. 
обрати внимание если мы формируем подтверждение предыдущим действиям и данные то посылка будет 
metadata[MdCommand.Sate]="clientCUDA"
metadata[MdCommand.Ok]="ok"
metadata[MdCommand.Data]=""
если просто данные
metadata[MdCommand.Sate]="clientCUDA"
metadata[MdCommand.Data]=""
----------------------
От сервера мы можем получить 
metadata[MdCommand.Sate]="servrCUDA"
metadata[MdCommand.Ok]="ok"
-----------------
подтверждении команды  и данные
дальше мы можем получить
metadata[MdCommand.Sate]="servrCUDA"
metadata[MdCommand.Ok]="ok"
metadata[MdCommand.Data]="dataok"
это значит что какая то предыдущая команда прошла и данные получены
------------
подтверждении команды  и данные
дальше мы можем получить
metadata[MdCommand.Sate]="servrCUDA"
metadata[MdCommand.Data]="dataok"
это значит данные получены все хорошо нужно проверить, что данные есть и дернуть 
  private void TrySendNext()
-----------------------------------------------------
подтверждении команды  и данные
дальше мы можем получить
metadata[MdCommand.Sate]="servrCUDA"
metadata[MdCommand.Data]="error"
должны повторить операцию с этими данными
-----------------------------------------------------
подтверждении команды  и данные
дальше мы можем получить
metadata[MdCommand.Sate]="servrCUDA"
metadata[MdCommand.Data]=... присутствие этой записи говорит что мы делаем манипуляции с памятью.
в то же самое время могут присутствовать команды metadata[MdCommand.Ok]
MdCommand.Data, MdCommand.DataOk - команда отвечает только за работу с данными 
сможешь построить каркас оптимальный по скорости 
case SateMode.Work:
 реадизации данного блока 

------------------------------------------------------

